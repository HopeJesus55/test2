[![Automated tests](https://github.com/HopeJesus55/test2/actions/workflows/run_tests.yml/badge.svg)](https://github.com/HopeJesus55/test2/actions/workflows/run_tests.yml)
[![Coverage Status](https://coveralls.io/repos/github/HopeJesus55/test2/badge.svg?branch=main)](https://coveralls.io/github/HopeJesus55/test2?branch=main)
[![Reliability Rating](https://sonarcloud.io/api/project_badges/measure?project=HopeJesus55_test2&metric=reliability_rating)](https://sonarcloud.io/summary/new_code?id=HopeJesus55_test2)
[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=HopeJesus55_test2&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=HopeJesus55_test2)
[![Security Rating](https://sonarcloud.io/api/project_badges/measure?project=HopeJesus55_test2&metric=security_rating)](https://sonarcloud.io/summary/new_code?id=HopeJesus55_test2)

Данная программа предназначена для решения задачи расщепления смеси случайных величин при помощи скрытого марковского процесса. 

Пользователь задаёт желаемые типы распределения случайных величин (экспоненциальное, нормальное), и соответствующие параметры для рассчета (мощность выборки, лямбда, среднее выборки и другие).

Сгенерированные выборки перемешиваются случайным образом, после чего, скрытый марковский процесс разделяет получившуюся смесь. 

Результатом работы программы является вывод, верно ли программа разделила смесь.

# План тестирования

# Аттестационное тестирование

  - Тест А1
    - Начальное состояние: Программа запущена. Программа запрашивает выбор типа распределения для первой выборки. Программа предлагает на выбор три варианта:
      ``` 
      1 - экспоненциальное распределение
      2 - нормальное распределение
      0 - выход из программы
      ``` 
    - Действие: Пользователь вводит в консоль неверное значение варианта, например, 5
    - Ожидаемый результат: Вывод в крнсоль сообщения: "Данная команда не распознана". Программа повторно выводит на экран запрос выбора

  - Тест А2
    - Начальное состояние: Программа запущена. Программа запрашивает выбор типа распределения для первой выборки. Программа предлагает на выбор три варианта: 
      ``` 
      1 - экспоненциальное распределение
      2 - нормальное распределение
      0 - выход из программы
      ``` 
    - Действие: Пользователь вводит в консоль 0
    - Ожидаемый результат: Программа завершается

  - Тест А3
    - Начальное состояние: Программа запущена. Программа запрашивает выбор типа распределения для первой выборки. Программа предлагает на выбор три варианта:
      ``` 
      1 - экспоненциальное распределение
      2 - нормальное распределение
      0 - выход из программы
      ``` 
    - Действие: Пользователь вводит в консоль 1
    - Ожидаемый результат: Запускается функция рассчета экспоненциального распределения. Вывод сообщения: "Введите мощность выборки"

  - Тест А4
    - Начальное состояние: Функция рассчета экспоненциального распределения, после вывода сообщения "Введите мощность выборки"
    - Действие: Пользователь вводит число 10
    - Ожидаемый результат: Сохранение значения, вывод сообщения "Введите значение лямбда"

  - Тест А5
    - Начальное состояние: Функция рассчета экспоненциального распределения, после сообщения "Введите значение лямбда"
    - Действие: Пользователь вводит значение 0.3
    - Ожидаемый результат: Успешный рассчет выборки из 10 экспоненциально-распределенных величин. Переход к запросу от пользователя типа распределения второй выборки.

  - Тест А6
    - Начальное состояние: Выбор пользователем распределения второй выборки. Программа предлагает три варианта:
      ``` 
      1 - экспоненциальное распределение
      2 - нормальное распределение
      0 - выход из программы
      ``` 
    - Действие: Пользователь вводит в консоль 2
    - Ожидаемый результат: Запускается функция рассчета нормального распределения. Вывод сообщения "Введите мощность выборки"

  - Тест А7
    - Начальное состояние: Функция рассчета нормального распределения, ввод мощности выборки
    - Действие: Пользователь вводит отрицательное значение, например -14
    - Ожидаемый результат: Вывод в консоль сообщения: "Мощность не может быть отрицательной!". Программа повторно выводит на экран запрос ввода мощности

  - Тест А8
    - Начальное состояние: Функция рассчета нормального распределения, после корректного ввода мощности. Программа выводит сообщение: "Введите значение среднего выборки"
    - Действие: Пользователь вводит 50
    - Ожидаемый результат: Сохранение значения, вывод сообщения "Введите среднеквадратичное отклонение"

  - Тест А9
    - Начальное состояние: Функция рассчета нормального распределения, ввод среднеквадратичного отклонения
    - Действие: Пользователь вводит 20
    - Ожидаемый результат: Успешный рассчет выборки нормально-распределенных величин. Переход к запросу от пользователя типа модели марковской цепи

  - Тест А10
    - Начальное состояние: Выбор модели марковской цепи. Программа предлагает на выбор три варианта:
      ``` 
      1 - Гауссовская
      2 - Гауссовская с возможными выбросами смеси
      0 - выход из программы
      ``` 
    - Действие: Пользователь вводит в консоль 1
    - Ожидаемый результат: Программа строит гауссовскую модель на основе рассчитанных ранее выборок случайных величин.
   
  - Тест А11
     - Начальное состояние: Построение гауссовской модели. Модель разделила выборки _неверно_
     - Действие: -
     - Ожидаемый результат: Вывод на экран сообщения "Модель разделила выборки неверно! :("

  - Тест А12
    - Начальное состояние: Построение гауссовской модели. Модель разделила выборки _верно_
    - Действие: -
    - Ожидаемый результат: Вывод на экран сообщения "Модель разделила выборки верно! :)"


# Блочное тестирование

## Класс SV
```
Класс - случаные величины
   @ count - мощность выборки
   @ numbers - список для "базовых" случаных чисел"""
```
  - Тест Б1
    - Описание: Проверка метода инициализации объекта класса
    - Метод: __init__
    - Входные данные: sv_obj = SV(10)
    - Ожидаемый результат: sv_obj.count = 10, sv_obj.numbers = []

  - Тест Б2
    - Описание: Проверка метода, генерирующего заданное кол-во случайных величин
    - Метод: _generate_base_numbers
    - Входные данные: sv_obj = SV(12), sv_obj._generate_random_base_numbers()
    - Ожидаемый результат:  len(sv_obj.numbers) = 12

### Класс-наследник ExpRasp

```
Класс-наследник SV - класс экспоненциального распределения случайных величин
   @ count - мощность выборки
   @ Lambda - лямбда, 1/среднее выборки (1/Tsp)
   @ rasp - список полученных экспоненциально-распределенных величин
```

  - Тест Б3
    - Описание: Проверка метода реализации объекта класса
    - Метод: __init__
    - Входные данные: exp_obj = ExpSV(10, 0.1)
    - Ожидаемый результат: exp_obj.count = 10, exp_obj.Lambda = 0.1, exp_obj.rasp = []

  - Тест Б4
    - Описание: Проверка метода генерации экспоненциального распределения заданного количества сл. величин.
    - Метод: generate_exp_rasp
    - Входные данные: exp_obj = ExpSV(10, 0.1), exp_obj.generate_exp_rasp()
    - Ожидаемый результат: len(exp_obj.rasp) = 10
   
### Класс-наследник NormRasp

```
Класс-наследник SV - класс нормального распределения случайных величин
   @ count - мощность выборки
   @ Tsp - среднее выборки
   @ Sigma - среднеквадратичное отклонение
   @ rasp - список полученных экспоненциально-распределенных величин
```

  - Тест Б5
    - Описание: Проверка метода реализации объекта класса
    - Метод: __init__
    - Входные данные: norm_obj = NormSV(10, 100, 30)
    - Ожидаемый результат: norm_obj.count = 10, norm_obj.Tsp = 100, norm_obj.Sigma = 30, norm_obj.rasp=  []

  - Тест Б6
    - Описание: Проверка метода генерации нормального распределения заданного количества сл. величин.
    - Метод: generate_norm_rasp
    - Входные данные: norm_obj = NormSV(10, 100, 30), norm_obj.generate_norm_rasp()    
    - Ожидаемый результат: len(norm_obj.rasp) = 10


## Класс HMM
```
Класс - скрытая модель Маркова (Hidden Markov Model). Свойства:
   @ X - первый список случ величин
   @ Y - второй список случ величин
   @ matrix - объединенный список (Х + У)
   @ shuffled - случайно перемешанная список (matrix)
   @ Z2 - предсказания
```

  - Тест Б7
    - Описание: Проверка метода реализации объекта класса
    - Метод: __init__
    - Входные данные: hmm_obj = HMM(10, 10)
    - Ожидаемый результат: hmm_obj.X = 10, hmm_obj.Y = 10, hmm_obj.matrix = [], hmm_obj.shuffled = [], hmm_obj.Z2 = []
  
  - Тест Б8
    - Описание: Проверка метода объединения двух списков
    - Метод: concat_SV
    - Входные данные: X = [1, 2], Y = [3, 4], hmm_obj = HMM(X, Y)
    - Ожидаемый результат: hmm_obj.concat_SV(X, Y) = [[1], [2], [3], [4]]

  - Тест Б9
    - Описание: Проверка метода случайного перемешивания элементов списка
    - Метод: shuffle_matrix
    - Входные данные: Х = [1, 2], Y = [3, 4, 5], hmm_obj = HMM(X, Y)
    - Ожидаемый результат: hmm_obj.shuffle_matrix() != [[1], [2], [3], [4], [5]]

  - Тест Б10
    - Описание: Проверка метода реализации Гауссовской модели скрытой цепи маркова
    - Метод: Gaussian_model
    - Входные данные: X = [1, 2, 3, 4], Y = [10, 15, 41, 19], hmm_obj = HMM(X, Y), hmm_obj.shuffle_matrix()
    - Ожидаемый результат: len(hmm_obj.Gaussian_model() = 8

  - Тест Б11
    - Описание: Проверка метода реализации Гауссовской модели скрытой цепи с возможными выбросами смеси
    - Метод: GMMHMM_model
    - Входные данные: X = [1, 2, 3, 4], Y = [10, 15, 41, 19], hmm_obj = HMM(X, Y), hmm_obj.shuffle_matrix()
    - Ожидаемый результат:len(hmm_obj.GMMHMM_model() = 7

  - Тест Б12
    - Описание: Проверка метода случая, когда модель разделяет случайные величины _верно_
    - Метод: check_correct_predict
    - Входные данные: 
    ```
        X = [11.67832142164908, 9.971898675188816, 25.01841276406762, 15.03967147266212]
        Y = [111.73482137940924, 108.3107229866111, 88.27019604202627, 120.30844003754476]
        hmm_obj = HMM(X, Y)
        hmm_obj.shuffle_matrix()
        hmm_obj.Gaussian_model()
    ```
    - Ожидаемый результат: hmm_obj.check_correct_predict() = True

  - Тест Б13
    - Описание: Проверка метода случая, когда модель разделяет случайные величины _неверно_
    - Метод: check_correct_predict
    - Входные данные: 
    ```
        X = [1, 0]
        Y = [35.37551597648314, 52.25567792055704, 55.671974648818214, 0.1131892096802, 0.1131892096802]
        hmm_obj = HMM(X, Y)
        hmm_obj.shuffle_matrix()
        hmm_obj.Gaussian_model()
    ```
    - Ожидаемый результат: hmm_obj.check_correct_predict() = False
    
# Интеграционное тестирование

- Тест I1
   - Взаимодействующие классы: ExpRasp и HMM
   - Описание: Тест проверяет взаимодействие классов ExpRasp и НММ. Генерируется два объекта класса ExpRasp, для каждого из объектов рассчитывается распределение величин. Создаётся объект класса HMM, в параметры которого передаются распределения объектов ExpRasp
   - Входные данные: hmm_obj.X, hmm_obj.Y
   - Ожидаемый результат: exp1_obj.rasp, exp2_obj.rasp

- Тест I2
   - Взаимодействующие классы: NormRasp и HMM
   - Описание: Тест проверяет взаимодействие классов NormRasp и НММ. Генерируется два объекта класса NormRasp, для каждого из объектов рассчитывается распределение величин. Создаётся объект класса HMM, в параметры которого передаются распределения объектов NormRasp
   - Входные данные: hmm_obj.X, hmm_obj.Y
   - Ожидаемый результат: norm1_obj.rasp, norm2_obj.rasp

- Тест I3
   - Взаимодействующие классы: ExpRasp, NormRasp и HMM
   - Описание: Тест проверяет взаимодействие классов ExpRasp и NormRasp с НММ. Генерируется два объекта - один класса ExpRasp, второй класса NormRasp. Для каждого из объектов рассчитывается распределение величин. Создаётся объект класса HMM, в параметры которого передаются распределения объектов ExpRasp и NormRasp
   - Входные данные: hmm_obj.X, hmm_obj.Y
   - Ожидаемый результат: exp1_obj.rasp, norm2_obj.rasp